/**
 * Code Execution Action
 *
 * Executes TypeScript code generated by the LLM.
 * This is the core of the code execution model - instead of JSON tool calls,
 * the agent writes code that imports from skills/ and we execute it.
 */

import { internalAction } from "../_generated/server";
import { v } from "convex/values";
import { exec } from "child_process";
import { promisify } from "util";
import * as fs from "fs/promises";
import * as path from "path";
import * as crypto from "crypto";

const execAsync = promisify(exec);

// Execution limits
const MAX_TIMEOUT_MS = 120_000; // 2 minutes
const MAX_OUTPUT_LENGTH = 50_000; // 50KB

/**
 * Execute TypeScript code in the sandbox.
 *
 * The code can import from /home/user/skills/ to use available capabilities.
 * Output is captured from stdout/stderr.
 */
export const execute = internalAction({
  args: {
    code: v.string(),
    timeoutMs: v.optional(v.number()),
  },
  handler: async (_ctx, args): Promise<{
    success: boolean;
    output: string;
    error?: string;
    exitCode: number;
  }> => {
    const timeout = Math.min(args.timeoutMs || 60_000, MAX_TIMEOUT_MS);

    // Generate unique filename for this execution
    const hash = crypto.createHash("md5").update(args.code).digest("hex").slice(0, 8);
    const filename = `/tmp/agent_exec_${Date.now()}_${hash}.ts`;

    try {
      // Write code to temp file
      await fs.writeFile(filename, args.code, "utf-8");

      // Execute with bun
      const { stdout, stderr } = await execAsync(`bun run ${filename}`, {
        timeout,
        cwd: "/home/user/workspace",
        env: {
          ...process.env,
          // Make skills available via import path
          NODE_PATH: "/home/user",
        },
        maxBuffer: MAX_OUTPUT_LENGTH * 2,
      });

      // Combine and truncate output
      let output = stdout || "";
      if (stderr) {
        output += stderr ? `\n[stderr]\n${stderr}` : "";
      }
      if (output.length > MAX_OUTPUT_LENGTH) {
        output = output.slice(0, MAX_OUTPUT_LENGTH) + "\n... (output truncated)";
      }

      return {
        success: true,
        output: output.trim(),
        exitCode: 0,
      };
    } catch (error: unknown) {
      const err = error as { message?: string; stdout?: string; stderr?: string; code?: number };
      const message = err.message || String(error);
      let output = "";

      // Capture any partial output
      if (err.stdout) output += err.stdout;
      if (err.stderr) output += `\n[stderr]\n${err.stderr}`;

      // Check for timeout
      if (message.includes("TIMEOUT") || message.includes("timed out")) {
        return {
          success: false,
          output: output.trim(),
          error: `Execution timed out after ${timeout}ms`,
          exitCode: 124,
        };
      }

      return {
        success: false,
        output: output.trim(),
        error: message,
        exitCode: err.code || 1,
      };
    } finally {
      // Clean up temp file
      try {
        await fs.unlink(filename);
      } catch {
        // Ignore cleanup errors
      }
    }
  },
});

/**
 * Extract code blocks from LLM response text.
 *
 * Supports:
 * - ```typescript ... ```
 * - ```ts ... ```
 * - ```javascript ... ```
 * - ```js ... ```
 * - ``` ... ``` (unmarked, treated as TypeScript)
 */
export function extractCodeBlocks(text: string): string[] {
  const blocks: string[] = [];

  // Match fenced code blocks
  const fenceRegex = /```(?:typescript|ts|javascript|js)?\s*\n([\s\S]*?)```/g;
  let match;

  while ((match = fenceRegex.exec(text)) !== null) {
    const code = match[1].trim();
    if (code.length > 0) {
      blocks.push(code);
    }
  }

  return blocks;
}

/**
 * Wrap code to ensure it can import from skills.
 *
 * Adds the necessary import path setup if not already present.
 */
export function wrapCodeForExecution(code: string): string {
  // If code already has imports from skills, use it as-is
  if (code.includes("from './skills/") || code.includes('from "./skills/')) {
    return code;
  }

  // If code has imports from 'skills/', adjust the path
  if (code.includes("from 'skills/") || code.includes('from "skills/')) {
    return code.replace(/from ['"]skills\//g, "from './skills/");
  }

  return code;
}
