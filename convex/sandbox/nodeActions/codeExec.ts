"use node";

/**
 * Code Execution Action
 *
 * Executes TypeScript code generated by the LLM.
 * This is the core of the code execution model - instead of JSON tool calls,
 * the agent writes code that imports from ksa/ and we execute it.
 */

import { internalAction } from "../_generated/server";
import { v } from "convex/values";

// Execution limits
const MAX_TIMEOUT_MS = 120_000; // 2 minutes
const MAX_OUTPUT_LENGTH = 50_000; // 50KB

/**
 * Execute TypeScript code in the sandbox.
 *
 * The code can import from /home/user/ksa/ to use available capabilities.
 * Output is captured from stdout/stderr.
 */
export const execute = internalAction({
  args: {
    code: v.string(),
    timeoutMs: v.optional(v.number()),
    env: v.optional(v.object({
      CONVEX_URL: v.optional(v.string()),
      GATEWAY_URL: v.optional(v.string()),
      LOCAL_CONVEX_URL: v.optional(v.string()),
      SANDBOX_JWT: v.optional(v.string()),
      CARD_ID: v.optional(v.string()),
      THREAD_ID: v.optional(v.string()),
    })),
  },
  handler: async (_ctx, args): Promise<{
    success: boolean;
    output: string;
    error?: string;
    exitCode: number;
  }> => {
    // Dynamic imports for Node.js modules (required for Convex bundling)
    const { exec } = await import("child_process");
    const { promisify } = await import("util");
    const fs = await import("fs/promises");
    const crypto = await import("crypto");

    const execAsync = promisify(exec);
    const timeout = Math.min(args.timeoutMs || 60_000, MAX_TIMEOUT_MS);

    // Generate unique filename for this execution
    // IMPORTANT: Write to /home/user/ so relative imports like './ksa/beads' resolve correctly
    const hash = crypto.createHash("md5").update(args.code).digest("hex").slice(0, 8);
    const filename = `/home/user/agent_exec_${Date.now()}_${hash}.ts`;

    try {
      // Write code to temp file
      await fs.writeFile(filename, args.code, "utf-8");

      // Execute with bun (use full path since PATH may not be set in Convex process)
      const bunPath = "/home/user/.bun/bin/bun";
      const { stdout, stderr } = await execAsync(`${bunPath} run ${filename}`, {
        timeout,
        cwd: "/home/user/workspace",
        env: {
          ...process.env,
          // Ensure PATH includes bun
          PATH: "/home/user/.bun/bin:/usr/local/bin:/usr/bin:/bin",
          HOME: "/home/user",
          // Make KSAs available via import path
          NODE_PATH: "/home/user",
          // Gateway config for KSAs to call cloud services
          ...(args.env?.CONVEX_URL && { CONVEX_URL: args.env.CONVEX_URL }),
          ...(args.env?.GATEWAY_URL && { GATEWAY_URL: args.env.GATEWAY_URL }),
          ...(args.env?.SANDBOX_JWT && { SANDBOX_JWT: args.env.SANDBOX_JWT }),
          ...(args.env?.CARD_ID && { CARD_ID: args.env.CARD_ID }),
          ...(args.env?.THREAD_ID && { THREAD_ID: args.env.THREAD_ID }),
        },
        maxBuffer: MAX_OUTPUT_LENGTH * 2,
      });

      // Combine and truncate output
      let output = stdout || "";
      if (stderr) {
        output += stderr ? `\n[stderr]\n${stderr}` : "";
      }
      if (output.length > MAX_OUTPUT_LENGTH) {
        output = output.slice(0, MAX_OUTPUT_LENGTH) + "\n... (output truncated)";
      }

      return {
        success: true,
        output: output.trim(),
        exitCode: 0,
      };
    } catch (error: unknown) {
      const err = error as { message?: string; stdout?: string; stderr?: string; code?: number };
      const message = err.message || String(error);
      let output = "";

      // Capture any partial output
      if (err.stdout) output += err.stdout;
      if (err.stderr) output += `\n[stderr]\n${err.stderr}`;

      // Check for timeout
      if (message.includes("TIMEOUT") || message.includes("timed out")) {
        return {
          success: false,
          output: output.trim(),
          error: `Execution timed out after ${timeout}ms`,
          exitCode: 124,
        };
      }

      return {
        success: false,
        output: output.trim(),
        error: message,
        exitCode: err.code || 1,
      };
    } finally {
      // Clean up temp file
      try {
        await fs.unlink(filename);
      } catch {
        // Ignore cleanup errors
      }
    }
  },
});
